/*
 * generated by Xtext 2.13.0
 */
package it.unibz.inf.ontouml.xtext.validation

import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import it.unibz.inf.ontouml.xtext.xcore.OntoUMLClass
import com.google.inject.Inject
import it.unibz.inf.ontouml.xtext.utils.ModelUtils
import it.unibz.inf.ontouml.xtext.xcore.XcorePackage
import it.unibz.inf.ontouml.xtext.xcore.Model
import it.unibz.inf.ontouml.xtext.xcore.GeneralizationSet

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class OntoUMLValidator extends AbstractOntoUMLValidator {
	
	@Inject extension ModelUtils
	
	public static val MISSING_IDENTITY_SUPPLIER = "it.unibz.inf.ontouml.xtext.validation.MISSING_IDENTITY_SUPPLIER"
	public static val ULTIMATE_SORTAL_SPECIALIZATION = "it.unibz.inf.ontouml.xtext.validation.ULTIMATE_SORTAL_SPECIALIZATION"
	public static val MULTIPLE_IDENTITY_SUPPLIERS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_IDENTITY_SUPPLIERS"
	public static val NONSORTAL_SPECIALIZATION_TO_SORTAL = "it.unibz.inf.ontouml.xtext.validation.NONSORTAL_SPECIALIZATION_TO_SORTAL"
	public static val RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.RIGID_SPECIALIZATION_TO_ANTI_RIGID"
	public static val SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID"
	public static val PHASE_MISSING_PARTITION = "it.unibz.inf.ontouml.xtext.validation.PHASE_MISSING_PARTITION"
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					OntoUMLPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check(CheckType.NORMAL)
	def checkUltimateSortalSpecialization(OntoUMLClass c) {
		if (c.isSortal) {
			val kinds = c.classHierarchy.filter[it.isUltimateSortal]
			if (kinds.isEmpty && !c.isUltimateSortal) {
//				println('''The class "«c.nameOrAlias»" must specialize a ultimate sortal '''+
//					'''(i.e., a class decorated with one stereotype from the set {'''+"«kind»,«relatorKind»,«modeKind»,«qualityKind»}).")
				error(
					'''The class "«c.nameOrAlias»" must specialize a ultimate sortal '''+
					'''i.e., a class decorated with one stereotype from the set {'''+"«kind»,«relatorKind»,«modeKind»,«qualityKind»}).", 
					c, XcorePackage.eINSTANCE.ontoUMLClass_GeneralizationsToSuperclasses, MISSING_IDENTITY_SUPPLIER)
			}
			if (!kinds.isEmpty && c.isUltimateSortal) {
//				println('''The class "«c.nameOrAlias»" is a ultimate sortal and cannot specialize '''+
//					'''other ultimate sortals («FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''')
				error(
				'''The class "«c.nameOrAlias»" is a ultimate sortal and cannot specialize '''+
					'''other ultimate sortals («FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.ontoUMLClass_GeneralizationsToSuperclasses, ULTIMATE_SORTAL_SPECIALIZATION)
			}
			if (kinds.size > 1 && !c.isUltimateSortal) {
//				println('''The class "«c.nameOrAlias»" is specializing mutiple ultimate '''+
//					'''sortals («FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''')
				error(
				'''The class "«c.nameOrAlias»" is specializing mutiple ultimate sortals '''+
					'''(«FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.ontoUMLClass_GeneralizationsToSuperclasses,MULTIPLE_IDENTITY_SUPPLIERS)
			}
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkNonSortalSpecializationToSortal(OntoUMLClass c) {
		if (c.isNonSortal) {
			val sortals = c.classHierarchy.filter[it.isSortal]
			if (!sortals.isEmpty) {
//				println('''The class "«c.nameOrAlias»" is non-sortal and cannot specialize sortal classes ('''+
//					'''«FOR s : sortals»«IF sortals.head!=s», «ENDIF»«s.nameOrAlias»«ENDFOR»).''')
				error(
				'''The class "«c.nameOrAlias»" is non-sortal and cannot specialize sortal classes ('''+
					'''«FOR s : sortals»«IF sortals.head!=s», «ENDIF»"«s.nameOrAlias»"«ENDFOR»).''', c, 
					XcorePackage.eINSTANCE.ontoUMLClass_GeneralizationsToSuperclasses, NONSORTAL_SPECIALIZATION_TO_SORTAL)
			}
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkNonAntiRigidSpecializationToAntiRigid(OntoUMLClass c) {
		if (c.isRigid || c.isSemiRigid) {
			val antiRigids = c.classHierarchy.filter[it.isAntiRigid]
			if (!antiRigids.isEmpty && c.isRigid) {
//				println('''The class "«c.nameOrAlias»" is rigid and cannot specialize anti-rigid classes ('''+
//					'''«FOR ar : antiRigids»«IF antiRigids.head!=ar», «ENDIF»"«ar.nameOrAlias»"«ENDFOR»).''')
				error(
				'''The class "«c.nameOrAlias»" is rigid and cannot specialize anti-rigid classes ('''+
					'''«FOR ar : antiRigids»«IF antiRigids.head!=ar», «ENDIF»"«ar.nameOrAlias»"«ENDFOR»).''', c, 
					XcorePackage.eINSTANCE.ontoUMLClass_GeneralizationsToSuperclasses, RIGID_SPECIALIZATION_TO_ANTI_RIGID)
			}
			if (!antiRigids.isEmpty && c.isSemiRigid) {
//				println('''The class "«c.nameOrAlias»" is semi-rigid and cannot specialize anti-rigid classes ('''+
//					'''«FOR ar : antiRigids»«IF antiRigids.head!=ar», «ENDIF»"«ar.nameOrAlias»"«ENDFOR»).''')
				error(
				'''The class "«c.nameOrAlias»" is semi-rigid and cannot specialize anti-rigid classes ('''+
					'''«FOR ar : antiRigids»«IF antiRigids.head!=ar», «ENDIF»"«ar.nameOrAlias»"«ENDFOR»).''', c, 
					XcorePackage.eINSTANCE.ontoUMLClass_GeneralizationsToSuperclasses, SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID)
			}
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkPhaseInPartition(OntoUMLClass c) {
		if (c.isPhase) {
			val partitionFound = (c.eContainer as Model).elements
				.exists[ 
					if(it instanceof GeneralizationSet)
						isIsDisjoint && isIsComplete && specifics.contains(c) && specifics.forall[ isPhase ]
					else 
						false
				]
			if(!partitionFound) {
//				println('''The class "«c.nameOrAlias»" is a phase and must be a member of some partition of phase '''+
//					'''(i.e., a disjoint and complete generalization set of phases).''')
				error(
					'''The class "«c.nameOrAlias»" is a phase and must be a member of some partition of phase '''
					+'''(i.e., a disjoint and complete generalization set of phases).''', c, 
					XcorePackage.eINSTANCE.ontoUMLClass_GeneralizationsToSuperclasses, PHASE_MISSING_PARTITION)
			}
		}
	}
	
}
