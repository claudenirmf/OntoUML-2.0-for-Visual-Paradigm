/**
 * generated by Xtext 2.13.0
 */
package it.unibz.inf.ontouml.xtext.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import it.unibz.inf.ontouml.xtext.utils.ModelUtils;
import it.unibz.inf.ontouml.xtext.validation.AbstractOntoUMLValidator;
import it.unibz.inf.ontouml.xtext.xcore.GeneralizationSet;
import it.unibz.inf.ontouml.xtext.xcore.Model;
import it.unibz.inf.ontouml.xtext.xcore.ModelElement;
import it.unibz.inf.ontouml.xtext.xcore.OntoUMLClass;
import it.unibz.inf.ontouml.xtext.xcore.XcorePackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class OntoUMLValidator extends AbstractOntoUMLValidator {
  @Inject
  @Extension
  private ModelUtils _modelUtils;
  
  public final static String MISSING_IDENTITY_SUPPLIER = "it.unibz.inf.ontouml.xtext.validation.MISSING_IDENTITY_SUPPLIER";
  
  public final static String ULTIMATE_SORTAL_SPECIALIZATION = "it.unibz.inf.ontouml.xtext.validation.ULTIMATE_SORTAL_SPECIALIZATION";
  
  public final static String MULTIPLE_IDENTITY_SUPPLIERS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_IDENTITY_SUPPLIERS";
  
  public final static String NONSORTAL_SPECIALIZATION_TO_SORTAL = "it.unibz.inf.ontouml.xtext.validation.NONSORTAL_SPECIALIZATION_TO_SORTAL";
  
  public final static String RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.RIGID_SPECIALIZATION_TO_ANTI_RIGID";
  
  public final static String SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID";
  
  public final static String PHASE_MISSING_PARTITION = "it.unibz.inf.ontouml.xtext.validation.PHASE_MISSING_PARTITION";
  
  @Check(CheckType.NORMAL)
  public void checkUltimateSortalSpecialization(final OntoUMLClass c) {
    boolean _isSortal = c.isSortal();
    if (_isSortal) {
      final Function1<OntoUMLClass, Boolean> _function = (OntoUMLClass it) -> {
        return Boolean.valueOf(it.isUltimateSortal());
      };
      final Iterable<OntoUMLClass> kinds = IterableExtensions.<OntoUMLClass>filter(this._modelUtils.getClassHierarchy(c), _function);
      if ((IterableExtensions.isEmpty(kinds) && (!c.isUltimateSortal()))) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The class \"");
        String _nameOrAlias = this._modelUtils.nameOrAlias(c);
        _builder.append(_nameOrAlias);
        _builder.append("\" must specialize a ultimate sortal ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("i.e., a class decorated with one stereotype from the set {");
        String _plus = (_builder.toString() + _builder_1);
        String _plus_1 = (_plus + "«kind»,«relatorKind»,«modeKind»,«qualityKind»}).");
        this.error(_plus_1, c, XcorePackage.eINSTANCE.getOntoUMLClass_GeneralizationsToSuperclasses(), OntoUMLValidator.MISSING_IDENTITY_SUPPLIER);
      }
      if (((!IterableExtensions.isEmpty(kinds)) && c.isUltimateSortal())) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("The class \"");
        String _nameOrAlias_1 = this._modelUtils.nameOrAlias(c);
        _builder_2.append(_nameOrAlias_1);
        _builder_2.append("\" is a ultimate sortal and cannot specialize ");
        StringConcatenation _builder_3 = new StringConcatenation();
        _builder_3.append("other ultimate sortals (");
        {
          for(final OntoUMLClass k : kinds) {
            {
              OntoUMLClass _head = IterableExtensions.<OntoUMLClass>head(kinds);
              boolean _notEquals = (!Objects.equal(_head, k));
              if (_notEquals) {
                _builder_3.append(", ");
              }
            }
            _builder_3.append("\"");
            String _nameOrAlias_2 = this._modelUtils.nameOrAlias(k);
            _builder_3.append(_nameOrAlias_2);
            _builder_3.append("\"");
          }
        }
        _builder_3.append(").");
        String _plus_2 = (_builder_2.toString() + _builder_3);
        this.error(_plus_2, c, XcorePackage.eINSTANCE.getOntoUMLClass_GeneralizationsToSuperclasses(), OntoUMLValidator.ULTIMATE_SORTAL_SPECIALIZATION);
      }
      if (((IterableExtensions.size(kinds) > 1) && (!c.isUltimateSortal()))) {
        StringConcatenation _builder_4 = new StringConcatenation();
        _builder_4.append("The class \"");
        String _nameOrAlias_3 = this._modelUtils.nameOrAlias(c);
        _builder_4.append(_nameOrAlias_3);
        _builder_4.append("\" is specializing mutiple ultimate sortals ");
        StringConcatenation _builder_5 = new StringConcatenation();
        _builder_5.append("(");
        {
          for(final OntoUMLClass k_1 : kinds) {
            {
              OntoUMLClass _head_1 = IterableExtensions.<OntoUMLClass>head(kinds);
              boolean _notEquals_1 = (!Objects.equal(_head_1, k_1));
              if (_notEquals_1) {
                _builder_5.append(", ");
              }
            }
            _builder_5.append("\"");
            String _nameOrAlias_4 = this._modelUtils.nameOrAlias(k_1);
            _builder_5.append(_nameOrAlias_4);
            _builder_5.append("\"");
          }
        }
        _builder_5.append(").");
        String _plus_3 = (_builder_4.toString() + _builder_5);
        this.error(_plus_3, c, XcorePackage.eINSTANCE.getOntoUMLClass_GeneralizationsToSuperclasses(), OntoUMLValidator.MULTIPLE_IDENTITY_SUPPLIERS);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkNonSortalSpecializationToSortal(final OntoUMLClass c) {
    boolean _isNonSortal = c.isNonSortal();
    if (_isNonSortal) {
      final Function1<OntoUMLClass, Boolean> _function = (OntoUMLClass it) -> {
        return Boolean.valueOf(it.isSortal());
      };
      final Iterable<OntoUMLClass> sortals = IterableExtensions.<OntoUMLClass>filter(this._modelUtils.getClassHierarchy(c), _function);
      boolean _isEmpty = IterableExtensions.isEmpty(sortals);
      boolean _not = (!_isEmpty);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The class \"");
        String _nameOrAlias = this._modelUtils.nameOrAlias(c);
        _builder.append(_nameOrAlias);
        _builder.append("\" is non-sortal and cannot specialize sortal classes (");
        StringConcatenation _builder_1 = new StringConcatenation();
        {
          for(final OntoUMLClass s : sortals) {
            {
              OntoUMLClass _head = IterableExtensions.<OntoUMLClass>head(sortals);
              boolean _notEquals = (!Objects.equal(_head, s));
              if (_notEquals) {
                _builder_1.append(", ");
              }
            }
            _builder_1.append("\"");
            String _nameOrAlias_1 = this._modelUtils.nameOrAlias(s);
            _builder_1.append(_nameOrAlias_1);
            _builder_1.append("\"");
          }
        }
        _builder_1.append(").");
        String _plus = (_builder.toString() + _builder_1);
        this.error(_plus, c, 
          XcorePackage.eINSTANCE.getOntoUMLClass_GeneralizationsToSuperclasses(), OntoUMLValidator.NONSORTAL_SPECIALIZATION_TO_SORTAL);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkNonAntiRigidSpecializationToAntiRigid(final OntoUMLClass c) {
    if ((c.isRigid() || c.isSemiRigid())) {
      final Function1<OntoUMLClass, Boolean> _function = (OntoUMLClass it) -> {
        return Boolean.valueOf(it.isAntiRigid());
      };
      final Iterable<OntoUMLClass> antiRigids = IterableExtensions.<OntoUMLClass>filter(this._modelUtils.getClassHierarchy(c), _function);
      if (((!IterableExtensions.isEmpty(antiRigids)) && c.isRigid())) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The class \"");
        String _nameOrAlias = this._modelUtils.nameOrAlias(c);
        _builder.append(_nameOrAlias);
        _builder.append("\" is rigid and cannot specialize anti-rigid classes (");
        StringConcatenation _builder_1 = new StringConcatenation();
        {
          for(final OntoUMLClass ar : antiRigids) {
            {
              OntoUMLClass _head = IterableExtensions.<OntoUMLClass>head(antiRigids);
              boolean _notEquals = (!Objects.equal(_head, ar));
              if (_notEquals) {
                _builder_1.append(", ");
              }
            }
            _builder_1.append("\"");
            String _nameOrAlias_1 = this._modelUtils.nameOrAlias(ar);
            _builder_1.append(_nameOrAlias_1);
            _builder_1.append("\"");
          }
        }
        _builder_1.append(").");
        String _plus = (_builder.toString() + _builder_1);
        this.error(_plus, c, 
          XcorePackage.eINSTANCE.getOntoUMLClass_GeneralizationsToSuperclasses(), OntoUMLValidator.RIGID_SPECIALIZATION_TO_ANTI_RIGID);
      }
      if (((!IterableExtensions.isEmpty(antiRigids)) && c.isSemiRigid())) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("The class \"");
        String _nameOrAlias_2 = this._modelUtils.nameOrAlias(c);
        _builder_2.append(_nameOrAlias_2);
        _builder_2.append("\" is semi-rigid and cannot specialize anti-rigid classes (");
        StringConcatenation _builder_3 = new StringConcatenation();
        {
          for(final OntoUMLClass ar_1 : antiRigids) {
            {
              OntoUMLClass _head_1 = IterableExtensions.<OntoUMLClass>head(antiRigids);
              boolean _notEquals_1 = (!Objects.equal(_head_1, ar_1));
              if (_notEquals_1) {
                _builder_3.append(", ");
              }
            }
            _builder_3.append("\"");
            String _nameOrAlias_3 = this._modelUtils.nameOrAlias(ar_1);
            _builder_3.append(_nameOrAlias_3);
            _builder_3.append("\"");
          }
        }
        _builder_3.append(").");
        String _plus_1 = (_builder_2.toString() + _builder_3);
        this.error(_plus_1, c, 
          XcorePackage.eINSTANCE.getOntoUMLClass_GeneralizationsToSuperclasses(), OntoUMLValidator.SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkPhaseInPartition(final OntoUMLClass c) {
    boolean _isPhase = c.isPhase();
    if (_isPhase) {
      EObject _eContainer = c.eContainer();
      final Function1<ModelElement, Boolean> _function = (ModelElement it) -> {
        boolean _xifexpression = false;
        if ((it instanceof GeneralizationSet)) {
          _xifexpression = (((((GeneralizationSet)it).isIsDisjoint() && ((GeneralizationSet)it).isIsComplete()) && ((GeneralizationSet)it).getSpecifics().contains(c)) && IterableExtensions.<OntoUMLClass>forall(((GeneralizationSet)it).getSpecifics(), ((Function1<OntoUMLClass, Boolean>) (OntoUMLClass it_1) -> {
            return Boolean.valueOf(it_1.isPhase());
          })));
        } else {
          _xifexpression = false;
        }
        return Boolean.valueOf(_xifexpression);
      };
      final boolean partitionFound = IterableExtensions.<ModelElement>exists(((Model) _eContainer).getElements(), _function);
      if ((!partitionFound)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The class \"");
        String _nameOrAlias = this._modelUtils.nameOrAlias(c);
        _builder.append(_nameOrAlias);
        _builder.append("\" is a phase and must be a member of some partition of phase ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("(i.e., a disjoint and complete generalization set of phases).");
        String _plus = (_builder.toString() + _builder_1);
        this.error(_plus, c, 
          XcorePackage.eINSTANCE.getOntoUMLClass_GeneralizationsToSuperclasses(), OntoUMLValidator.PHASE_MISSING_PARTITION);
      }
    }
  }
}
